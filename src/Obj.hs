{-|
Module      : Obj
Description : Loader for .obj files
Maintainer  : rukokarasu@gmail.com
Stability   : experimental
-}

{-# LANGUAGE FlexibleContexts #-}

module Obj
    (sceneFromObj
    ) where

{- 4/15/2017
This module reads .obj files as generated by Blender.
As of right now, the commented headers must be manually removed in order to
parse. Also, the mtl file should be completely different from that exported
from a Blender project. Each material entry should look like this

newmtl $NAME
Type $TYPE
RGB $X $Y $Z

where $NAME is any string containing alphanumeric characters or . or _
      $TYPE is either Diffuse or Emit or Reflect
      $X, $Y, and $Z can be read as floating point numbers

RGB will be the emission color for things with type Emit and otherwise will
be the fraction of each component of incoming light that gets reflected.

It does not accept regular mtl files bc that format is based on Phong shading
and this is a raytracer, hence only the diffuse color can be relevant and the
rest is just noise. My test models don't need many materials so it's not too
much work to just manually enter the material data.

I expect this to change when I start to use more complex materials, in
particular when i want to make something not fully reflective or add refraction
or something.
-}

import Color hiding (surfaceType)
import BIH hiding (bounds)
import Geometry hiding (vertex)

import qualified Debug.Trace as Trace
import Linear.V3
import Text.Parsec
import Text.Parsec.Char
import Text.Parsec.Combinator

-- |Load the material referenced by a .obj file and generate a Scene.
sceneFromObj :: String -> IO Scene
sceneFromObj str = do
    case parse loadObjFile "" str of
        Right (mtllib, objs) -> do
            mtlFile <- readFile ("./data/" ++ mtllib)
            case parse loadMtlFile "" mtlFile of
                Right mats -> do
                    let triangles = makeScene objs mats
                    Trace.trace (show $ head objs) (return ())
                    Trace.trace (show mats) (return ())
                    return $ Scene (boundingBox triangles) (makeBIH triangles)
                Left _ -> fail "sceneFromObj: Couldn't parse referenced MTL file."
        Left _ -> fail "sceneFromObj: Couldn't parse OBJ file."

-- |Match each object with it's material and return the resulting scene.
makeScene :: [Object] -> [(String, Material Float)] -> [Triangle]
makeScene objs mats =
    let matches = [(obj, mat) | obj <- objs, mat <- mats, mtl obj == fst mat]
    in  concatMap (makeTris allVerts) matches
        where allVerts = concatMap verts objs

-- |Convert the object to a list of triangles all having the given material.
makeTris :: [V3 Float] -> (Object, (String, Material Float)) -> [Triangle]
makeTris vertices (obj, mat) = map makeTri $ faces obj
    where makeTri (V3 a b c) =
              Triangle (vertices !! (a-1))
                       (vertices !! (b-1))
                       (vertices !! (c-1))
                       (snd mat)

data Object = Object {
    name :: String,
    mtl :: String,
    verts :: [V3 Float],
    faces :: [V3 Int]
} deriving Show

loadObjFile :: Stream s m Char => ParsecT s u m (String, [Object])
loadObjFile = do
  lib <- mtllib
  objs <- many parseObj
  return (lib, objs)

parseObj :: Stream s m Char => ParsecT s u m Object
parseObj = do
  name <- objectName
  verts <- many vertex
  mtl <- materialName
  optional parseS
  faces <- many face
  return $ Object name mtl verts faces

objectName :: Stream s m Char => ParsecT s u m String
objectName = do
    char 'o'
    spaces
    name <- many1 (alphaNum <|> oneOf "._") -- many1 $ noneOf " \t\n\r\f\v"
    spaces
    return name

vertex :: Stream s m Char => ParsecT s u m (V3 Float)
vertex = do
    char 'v'
    spaces
    v1 <- fractional
    spaces
    v2 <- fractional
    spaces
    v3 <- fractional
    spaces
    return $ fmap read (V3 v1 v3 v2)

fractional :: Stream s m Char => ParsecT s u m String
fractional = do
    m <- option "" $ string "-"
    d1 <- many digit
    p <- option "" $ string "."
    d2 <- many digit
    return $ m ++ d1 ++ p ++ d2

materialName :: Stream s m Char => ParsecT s u m String
materialName = do
    string "usemtl"
    spaces
    mtl <- many1 $ noneOf " \t\n\r\f\v"
    spaces
    return mtl

mtllib :: Stream s m Char => ParsecT s u m String
mtllib = do
    string "mtllib"
    spaces
    filename <- many1 $ noneOf " \t\n\r\f\v"
    spaces
    return filename

parseS :: Stream s m Char => ParsecT s u m ()
parseS = do
    try (string "s on") <|> string "s off"
    spaces

face :: Stream s m Char => ParsecT s u m (V3 Int)
face = do
    char 'f'
    spaces
    f1 <- many1 digit
    spaces
    f2 <- many1 digit
    spaces
    f3 <- many1 digit
    spaces
    return $ fmap readInt (V3 f1 f2 f3)
        where readInt x = read x :: Int

loadMtlFile :: Stream s m Char => ParsecT s u m [(String, Material Float)]
loadMtlFile = many loadMtl

loadMtl :: Stream s m Char => ParsecT s u m (String, Material Float)
loadMtl = do
    name <- (string "newmtl " >> many (noneOf " \t\n\r\f\v"))
    spaces
    surfType <- surfaceType
    string "RGB "
    col <- vec3
    spaces
    return (name, Mat (toRGB col) (read surfType))
        where toRGB (V3 a b c) = RGB a b c

vec3 :: Stream s m Char => ParsecT s u m (V3 Float)
vec3 = do
    v1 <- fractional
    spaces
    v2 <- fractional
    spaces
    v3 <- fractional
    spaces
    return $ fmap read (V3 v1 v2 v3)

-- Diffuse/reflect not yet implemented but it might be in the file
surfaceType :: Stream s m Char => ParsecT s u m String
surfaceType = do
    string "Type "
    surfType <- try (string "Diffuse") <|> try (string "Reflect") <|> string "Emit"
    spaces
    return surfType
