{-|
Module      : Obj
Description : Loader for .obj files
Maintainer  : rukokarasu@gmail.com
Stability   : experimental
-}

{-# LANGUAGE FlexibleContexts #-}

module Obj
    (sceneFromObj
    ) where

{-
This module reads .obj files as generated by Blender.
As of right now, the commented headers must be manually removed in order to
parse. Also, the mtl file should be completely different from that exported
from a Blender project. Each material entry should look like this

newmtl $NAME
reflective $REF
RGB $RX $RY $RZ
emissive $EM
RGB $EX $EY $EZ

where $NAME is any string containing alphanumeric characters or . or _
      $REF indicates the degree of reflectiveness, which is between 0 and 1
      $EM indicates the brightness of the emitted light 
      $X, $Y, and $Z can be read as floating point numbers

It does not accept regular mtl files bc that format is based on Phong shading
and this is a raytracer, hence only the diffuse color can be relevant and the
rest is just noise. My test models don't need many materials so it's not too
much work to just manually enter the material data.

I expect this to change when I start to use more complex materials, in
particular when i want to make something not fully reflective or add refraction
or something.
-}

import Color hiding (surfaceType)
import BIH hiding (bounds)
import Geometry hiding (vertex)

import qualified Debug.Trace as Trace
import Linear.V3
import Text.Parsec
import Text.Parsec.Char
import Text.Parsec.String
import Text.Parsec.Combinator

-- |Load the material referenced by a .obj file and generate a Scene.
sceneFromObj :: String -> IO Scene
sceneFromObj str = 
    case parse loadObjFile "" str of
        Right (mtllib, objs) -> do
            mtlFile <- readFile ("./data/" ++ mtllib)
            case parse loadMtlFile "" mtlFile of
                Right mats -> do
                    let triangles = makeScene objs mats
                    Trace.trace (show $ head objs) (return ())
                    Trace.trace (show mats) (return ())
                    return $ Scene (boundingBox triangles) (makeBIH triangles)
                Left err -> fail $ show err
        Left _ -> fail "sceneFromObj: Couldn't parse OBJ file."

-- |Match each object with it's material and return the resulting scene.
makeScene :: [Object] -> [(String, Material)] -> [Triangle]
makeScene objs mats =
    let matches = [(obj, mat) | obj <- objs, mat <- mats, mtl obj == fst mat]
    in  concatMap (makeTris allVerts) matches
        where allVerts = concatMap verts objs

-- |Convert the object to a list of triangles all having the given material.
makeTris :: [V3 Float] -> (Object, (String, Material)) -> [Triangle]
makeTris vertices (obj, mat) = map makeTri $ faces obj
    where makeTri (V3 a b c) =
              Triangle (vertices !! (a-1))
                       (vertices !! (b-1))
                       (vertices !! (c-1))
                       (snd mat)

data Object = Object {
    name :: String,
    mtl :: String,
    verts :: [V3 Float],
    faces :: [V3 Int]
} deriving Show

loadObjFile :: Parser (String, [Object])
loadObjFile = do
  lib <- mtllib
  objs <- many parseObj
  return (lib, objs)

parseObj :: Parser Object
parseObj = do
  name <- objectName
  verts <- many vertex
  mtl <- materialName
  optional parseS
  faces <- many face
  return $ Object name mtl verts faces

objectName :: Parser String
objectName = do
    char 'o'
    spaces
    name <- many1 (alphaNum <|> oneOf "._") -- many1 $ noneOf " \t\n\r\f\v"
    spaces
    return name

vertex :: Stream s m Char => ParsecT s u m (V3 Float)
vertex = do
    char 'v'
    spaces
    v1 <- fractional
    spaces
    v2 <- fractional
    spaces
    v3 <- fractional
    spaces
    return (V3 v1 v3 v2)

fractional :: Stream s m Char => ParsecT s u m Float
fractional = do
    m <- option "" $ string "-"
    d1 <- many digit
    p <- option "" $ string "."
    d2 <- many digit
    return . read $ m ++ d1 ++ p ++ d2

materialName :: Stream s m Char => ParsecT s u m String
materialName = do
    string "usemtl"
    spaces
    mtl <- many1 $ noneOf " \t\n\r\f\v"
    spaces
    return mtl

mtllib :: Stream s m Char => ParsecT s u m String
mtllib = do
    string "mtllib"
    spaces
    filename <- many1 $ noneOf " \t\n\r\f\v"
    spaces
    return filename

parseS :: Stream s m Char => ParsecT s u m ()
parseS = do
    try (string "s on") <|> string "s off"
    spaces

face :: Parser (V3 Int)
face = do
    char 'f'
    spaces
    f1 <- many1 digit
    spaces
    f2 <- many1 digit
    spaces
    f3 <- many1 digit
    spaces
    return $ fmap readInt (V3 f1 f2 f3)
        where readInt x = read x :: Int

loadMtlFile :: Parser [(String, Material)]
loadMtlFile = many loadMtl

loadMtl :: Parser (String, Material)
loadMtl = do 
    name <- (string "newmtl " >> many (noneOf " \t\n\r\f\v"))
    spaces
    ref <- string "reflective " >> fractional
    spaces
    refColor <- rgbColor
    spaces
    emit <- string "emissive " >> fractional
    spaces
    emitColor <- rgbColor
    spaces
    return (name, Mat ref refColor emit emitColor)

{-
reflective :: Parser Float
reflective = do
    string "reflective "
    fractional

emissive :: Parser Float
emissive = do
    string "emissive "
    fractional
-}

rgbColor :: Parser (RGB Float)
rgbColor = do
    string "RGB "
    V3 x y z <- vec3
    return (RGB x y z)

vec3 :: Parser (V3 Float)
vec3 = do
    v1 <- fractional
    spaces
    v2 <- fractional
    spaces
    v3 <- fractional
    spaces
    return $ (V3 v1 v2 v3)

-- Diffuse/reflect not yet implemented but it might be in the file
surfaceType :: Parser String
surfaceType = do
    string "Type "
    surfType <- try (string "Diffuse") <|> try (string "Reflect") <|> string "Emit"
    spaces
    return surfType
